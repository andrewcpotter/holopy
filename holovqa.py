#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
holovqa v0.1
holographic MPS variational quantum algorithms 


Created on Mon Oct  5 09:58:45 2020
@author: acpotter
"""
#%% imports
import numpy as np
import cirq
#import sympy 

import mps
import tenpy

#%% 

#%% 
class IsoTensor(object):
    """
        node of an isometric tensor-network, generated by parameterized cirq unitary
        works equally for tensor network state (TNS) or operator (TNO); 
        for TNS: physical register implicitly assumed to start from reference state: |00..0> 
        
        Intention: circuit object intended to be easily adaptable to work equally with cirq, qiskit, etc...
    """
    def __init__(self,qubits,param_names,circuit=None,circuit_format = 'cirq'):
        """
        creates isometric tensor site for list of bond-register sizes
        intputs:
            qubits, list of qubit-registers, object-type depends on circuit_format (e.g. cirq, qiskit, etc...)
                note:
                    number of outgoing legs is automatically the same as incoming ones
                    0th leg denotes the physical leg, 
                    j>1 entries are (incoming) bond-legs
            param_names, list of circuit-parameter names as strings
            circuit, circuit object (type specified by circuit_format)
            circuit_format, optional (default = 'cirq'), specifies which circuit 
                construction package to use for circuits
        """
        self.param_names = param_names
        self.n_params = len(param_names)
        self.circuit_format = circuit_format
        self.regdims = [len(reg) for reg in qubits]
        self.qubits = qubits
        self.tensor_shape = np.append(2**np.array(self.regdims),2**np.array(self.regdims))
        
        if circuit_format == 'cirq':
            ## setup circuit(s) ##
            if circuit==None:
                self.circuit  = cirq.Circuit()
            else:
                self.cicruit = circuit
        else:
            raise NotImplementedError('Only cirq implemented')
            
    def set_param_names(self,param_names):
        self.param_names= param_names
        self.n_params = len(param_names)

    def unitary(self,params):
        """
        calls circuit simulator to construct unitary
        returns in shape specified by regdims
        inputs:
            - params, pp.array of parameter values
        """
        if self.circuit_format == 'cirq':            
            u = self.unitary_cirq(params)
        else:
            raise NotImplementedError('Only cirq implemented')
        return u
    
    def unitary_cirq(self,params):
        """ unitary constructor for cirq-based circuits """
        param_dict = dict(zip(self.param_names,params))
        qubit_order = [q for qreg in self.qubits for q in qreg] # order to return the qubit unitary
        # resolve the symbolic circuit parameters to numerical values
        resolver = cirq.ParamResolver(param_dict)
        resolved_circuit = cirq.resolve_parameters(self.circuit, resolver)   
        u = resolved_circuit.unitary(qubit_order = qubit_order)
        return u.reshape(self.tensor_shape) # reshape as a multi-leg tensor

#%%
class HoloMPS(object):
    """
    Object for: Holographic MPS generated by variational/parameterized circuit 
    """
    
    
    def __init__(self,phys_qubits, bond_qubits,circuits,param_names,bdry_circ=None,circuit_format = 'cirq'):
        """
        inputs:
            phys_qubits, register of physical qubits, 
            bond_qubits, register of bond qubits,
                (for cirq: register= list of named qubits)
            l_uc, int, number of sites in unit cell
            circuits, list, of circuits for each site in unit-cell
            param_names,list of sympy symbols, parameterized gate parameters (shared by all tensors)
            bdry_circ, (optional, default = None), boundary vector circuit for prepping initial state of bond-qubits
            circuit_format, str, (default='cirq'), type of circuit editor/simulator used
        """

        self.l_uc = len(circuits) # length of unit cell
        self.param_names = param_names # list of sympy symbols (shared by all tensors)
        self.n_params = len(param_names)
        
        if circuit_format == 'cirq':
            self.nphys = len(phys_qubits) # number of physical qubits
            self.nbond = len(bond_qubits) # number of bond qubits

            # make the MPS/tensor-train -- same qubits used by each tensor
            self.bdry_tensor = IsoTensor([bond_qubits],self.param_names,bdry_circ) # tensor for left boundary vector
            self.sites = [IsoTensor([phys_qubits,bond_qubits],
                                    self.param_names,
                                    circuits[j],
                                    circuit_format='cirq') for j in range(self.l_uc)]

        else:
            raise NotImplementedError('Only cirq implemented')
            
    
    
    ## cpu simulation ##  
    def left_bdry_vector(self,params):
        """
        computes full unitaries for each state (any initial state for physicalqubit)
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        returns:
            bdry_vec, unitary correspond to boundary
            ulist, list of unitaries for tensors in unit cell
        """
        bvec_l = self.bdry_tensor.unitary(params)[:,0] # boundary circuit tensor 
        return bvec_l
    
    def unitaries(self,params):
        """
        computes full unitaries for each state (any initial state for physicalqubit)
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        returns:
            ulist, list of rank-4 tensors for each site in unit cell
        """
        ulist = [self.sites[j].unitary(params) for j in range(self.l_uc)]
        return ulist
    
    def tensors(self,params):
        """
        computes tensors for fixed initial state of physical qubit = |0>
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        returns:
            tensors, list of rank-3 tensors for each site in unit cell
        """
        tensors = [self.sites[j].unitary(params)[:,:,0,:] for j in range(self.l_uc)]
        return tensors
    
    ## Convert to other format(s) ##
    def to_tenpy(self,params,L=1):
        """
        inputs:
            params, dictionary of parameters {'name':numerical-value}
            L, int, number of repetitions of unit cell, 
                set to np.inf for iMPS
            TODO: add any other args needed to specify, symmetries, site-type etc...
        outputs:
            tenpy MPS object created from cirq description
        """
        site = tenpy.networks.site.SpinHalfSite(conserve=None)
        if (L==np.inf) and (self.l_uc==1) and (self.nphys==1):
            B = np.swapaxes(self.tensors(params)[0],1,2)
            psi = tenpy.networks.mps.MPS.from_Bflat([site], 
                                                [B], 
                                                bc='infinite', 
                                                dtype=complex, 
                                                form=None)
            
        else:
            B_arrs = [np.swapaxes(tensor,1,2) for tensor in self.tensors(params)]
            B_arrs[0] = B_arrs[0][:,0:1,:]
            B_arrs[-1] = B_arrs[-1][:,:,0:1]
            psi = tenpy.networks.mps.MPS.from_Bflat([site]*L,
                                                    B_arrs, 
                                                    bc = 'finite', 
                                                    dtype=complex, 
                                                    form=None)    
        psi.canonical_form()
        psi.convert_form(psi.form)
        return psi    
    
    def as_mps(self,params,L=1):
        """
        converts to custom MPS class object
        inputs:
            params, dictionary of parameters {'name':numerical-value}
            L, int, number of repetitions of unit cell, 
                set to np.inf for iMPS
        outputs:
            custom MPS object created from cirq description
        """
        tensors = self.tensors(params)
        bvecl = self.left_bdry_vector(params)
        state = mps.MPS(tensors,L=L,bdry_vecs=[bvecl,None], rcf = True)
        return state
    
    def as_mpo(self,params):
        """
        converts to custom MPO class object
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        outputs:
            custom MPS object created from cirq description
        """
        tensors = self.compute_unitaries(params)
        bvecl = self.compute_left_bdry_vector(params)
        op = mps.MPO(tensors,L=self.L,bdry_vecs=[bvecl,None], rcf = True)
        return op
        
    ##  correlation function sampling ##
    def sample_correlations(self,L,bases,N_samples):
        """
        basis: measurement basis for each site
            possible formats: 
                - cirq circuit for physical qubits that maps physical qubits to measurement basis
                - string of 
        possible backends:  
            'tenpy' - uses 
            'qasm' - output qasm script to measure
            
        inputs:
            options: dictionary with entries specifying:
                burn-in length, 
                unit cell length, 
                basis to measure in for each site,
                number of samples to take (could be infinite for cpu-simulations)
                backend: whether to run as 
                
        """
        raise NotImplementedError
      
#%% 

#%%





